// Akai S5000/S6000 AKP to SFZ Converter - v0.7
//
// This version marks the transition from a parser to a converter.
// It takes the parsed data and generates a functional .sfz file.
//
// Key Changes:
// 1. Added a `to_sfz_string()` method to generate SFZ output from the parsed data.
// 2. Implemented mapping from AKP parameters to SFZ opcodes (e.g., key ranges, envelopes).
// 3. Added initial scaling for values like envelope times to make the output usable.
// 4. The main function now saves the generated SFZ content to a file.
//
// To compile and run this:
// 1. Make sure you have Rust installed: https://www.rust-lang.org/tools/install
// 2. Create a new project: `cargo new akp_converter`
// 3. `cd akp_converter`
// 4. Add the `byteorder` crate to your `Cargo.toml` file:
//    [dependencies]
//    byteorder = "1.4"
// 5. Replace the contents of `src/main.rs` with this code.
// 6. Place an .akp file (e.g., "test.akp") in the root of the project directory.
// 7. Run the program: `cargo run -- test.akp`
// 8. A new "test.sfz" file should be created!

use byteorder::{LittleEndian, ReadBytesExt};
use std::env;
use std::fs::{self, File};
use std::io::{self, Read, Seek, SeekFrom, Cursor, Write};
use std::path::Path;
use std::str;

// --- Data Structures ---

#[derive(Debug, Default)]
struct AkaiProgram {
    header: Option<ProgramHeader>,
    keygroups: Vec<Keygroup>,
}

#[derive(Debug, Default)]
struct ProgramHeader {
    midi_program_number: u8,
    number_of_keygroups: u8,
}

#[derive(Debug, Default)]
struct Keygroup {
    low_key: u8,
    high_key: u8,
    low_vel: u8,
    high_vel: u8,
    sample: Option<Sample>,
    tune: Option<Tune>,
    filter: Option<Filter>,
    amp_env: Option<Envelope>,
    filter_env: Option<Envelope>,
    aux_env: Option<Envelope>,
    lfo1: Option<Lfo>,
    lfo2: Option<Lfo>,
}

#[derive(Debug, Default)]
struct Sample {
    filename: String,
}

#[derive(Debug, Default)]
struct Tune {
    level: u8,
    semitone: i8,
    fine_tune: i8,
}

#[derive(Debug, Default)]
struct Filter {
    cutoff: u8,
    resonance: u8,
    filter_type: u8,
}

#[derive(Debug, Default)]
struct Envelope {
    attack: u8,
    decay: u8,
    sustain: u8,
    release: u8,
}

#[derive(Debug, Default)]
struct Lfo {
    waveform: u8,
    rate: u8,
    delay: u8,
    depth: u8,
}

#[derive(Debug)]
struct RiffChunkHeader {
    id: String,
    size: u32,
}

// --- SFZ Generation Logic ---

impl AkaiProgram {
    /// Converts the parsed AkaiProgram into an SFZ formatted string.
    pub fn to_sfz_string(&self) -> String {
        let mut sfz_content = String::new();
        sfz_content.push_str("// Generated by Akai AKP to SFZ Converter\n\n");

        for keygroup in &self.keygroups {
            sfz_content.push_str("<region>\n");

            // Sample
            if let Some(sample) = &keygroup.sample {
                // SFZ expects backslashes, so we replace them.
                sfz_content.push_str(&format!("sample={}\n", sample.filename.replace("\\", "/")));
            }

            // Key/Velocity Range
            sfz_content.push_str(&format!("lokey={}\n", keygroup.low_key));
            sfz_content.push_str(&format!("hikey={}\n", keygroup.high_key));
            sfz_content.push_str(&format!("lovel={}\n", keygroup.low_vel));
            sfz_content.push_str(&format!("hivel={}\n", keygroup.high_vel));

            // Tune/Level
            if let Some(tune) = &keygroup.tune {
                // AKP level is 0-100. Let's map it to a dB range, e.g., -48dB to 0dB.
                let volume_db = (tune.level as f32 / 100.0) * 48.0 - 48.0;
                sfz_content.push_str(&format!("volume={:.2}\n", volume_db));
                sfz_content.push_str(&format!("tune={}\n", tune.semitone));
                sfz_content.push_str(&format!("fine_tune={}\n", tune.fine_tune));
            }

            // Amp Envelope
            if let Some(env) = &keygroup.amp_env {
                // Simple scaling. AKP 0-100 -> SFZ seconds. This needs refinement.
                sfz_content.push_str(&format!("ampeg_attack={:.3}\n", (env.attack as f32).powf(2.0) / 10000.0));
                sfz_content.push_str(&format!("ampeg_decay={:.3}\n", (env.decay as f32).powf(2.0) / 10000.0 * 2.0));
                sfz_content.push_str(&format!("ampeg_sustain={}\n", env.sustain));
                sfz_content.push_str(&format!("ampeg_release={:.3}\n", (env.release as f32).powf(2.0) / 10000.0 * 4.0));
            }
            
            // Filter
            if let Some(filter) = &keygroup.filter {
                if filter.filter_type > 0 {
                    match filter.filter_type {
                        1 => sfz_content.push_str("fil_type=lpf_2p\n"),
                        2 => sfz_content.push_str("fil_type=bpf_2p\n"),
                        3 => sfz_content.push_str("fil_type=hpf_2p\n"),
                        _ => {}
                    }
                    // AKP 0-100 -> SFZ Hz (logarithmic scale)
                    let cutoff_hz = 20.0 * (2.0f32).powf(10.0 * filter.cutoff as f32 / 100.0);
                    sfz_content.push_str(&format!("cutoff={:.1}\n", cutoff_hz));
                    // AKP 0-100 -> SFZ dB
                    let resonance_db = filter.resonance as f32 * 0.4;
                    sfz_content.push_str(&format!("resonance={:.1}\n", resonance_db));
                }
            }

            sfz_content.push_str("\n");
        }

        sfz_content
    }
}

// --- Main Application Logic ---

fn main() -> io::Result<()> {
    println!("--- Akai AKP to SFZ Converter v0.7 ---");

    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        println!("Usage: cargo run -- <path_to_akp_file>");
        return Ok(());
    }
    let file_path_str = &args[1];
    println!("-> Parsing: {}", file_path_str);

    let mut file = File::open(file_path_str)?;
    validate_riff_header(&mut file)?;

    let mut program = AkaiProgram::default();
    parse_top_level_chunks(&mut file, file.metadata()?.len(), &mut program)?;

    println!("-> Parsing complete.");
    
    // --- Generate and Save SFZ ---
    println!("-> Generating SFZ content...");
    let sfz_output = program.to_sfz_string();
    
    let input_path = Path::new(file_path_str);
    let sfz_path = input_path.with_extension("sfz");
    
    println!("-> Saving SFZ file to: {:?}", sfz_path);
    fs::write(&sfz_path, sfz_output)?;
    
    println!("\n--- Conversion Complete ---");
    println!("Successfully created {:?}.", sfz_path);

    Ok(())
}

// --- Parsing Functions (largely unchanged from v0.6) ---

fn validate_riff_header(file: &mut File) -> io::Result<()> {
    let mut buf = [0u8; 4];
    file.read_exact(&mut buf)?;
    if str::from_utf8(&buf).unwrap_or("") != "RIFF" {
        return Err(io::Error::new(io::ErrorKind::InvalidData, "Not a RIFF file"));
    }
    file.seek(SeekFrom::Current(4))?;
    file.read_exact(&mut buf)?;
    if str::from_utf8(&buf).unwrap_or("") != "APRG" {
        return Err(io::Error::new(io::ErrorKind::InvalidData, "Not an APRG file"));
    }
    Ok(())
}

fn parse_top_level_chunks(file: &mut File, end_pos: u64, program: &mut AkaiProgram) -> io::Result<()> {
    while file.stream_position()? < end_pos {
        let header = read_chunk_header(file)?;
        match header.id.as_str() {
            "prg " => {
                let mut chunk_data = vec![0; header.size as usize];
                file.read_exact(&mut chunk_data)?;
                program.header = Some(parse_program_header(&mut Cursor::new(chunk_data))?);
            }
            "kgrp" => {
                let kgrp_end_pos = file.stream_position()? + header.size as u64;
                let keygroup = parse_keygroup(file, kgrp_end_pos)?;
                program.keygroups.push(keygroup);
            }
            _ => {
                file.seek(SeekFrom::Current(header.size as i64))?;
            }
        }
    }
    Ok(())
}

fn parse_keygroup(file: &mut File, end_pos: u64) -> io::Result<Keygroup> {
    let mut keygroup = Keygroup::default();
    let mut env_count = 0;
    let mut lfo_count = 0;

    while file.stream_position()? < end_pos {
        let header = read_chunk_header(file)?;
        let mut chunk_data = vec![0; header.size as usize];
        file.read_exact(&mut chunk_data)?;
        let mut cursor = Cursor::new(chunk_data);

        match header.id.as_str() {
            "zone" => parse_zone_chunk(&mut cursor, &mut keygroup)?,
            "smpl" => keygroup.sample = Some(parse_smpl_chunk(&mut cursor)?),
            "tune" => keygroup.tune = Some(parse_tune_chunk(&mut cursor)?),
            "filt" => keygroup.filter = Some(parse_filt_chunk(&mut cursor)?),
            "env " => {
                let envelope = parse_env_chunk(&mut cursor)?;
                match env_count {
                    0 => keygroup.amp_env = Some(envelope),
                    1 => keygroup.filter_env = Some(envelope),
                    2 => keygroup.aux_env = Some(envelope),
                    _ => {}
                }
                env_count += 1;
            }
            "lfo " => {
                let lfo = parse_lfo_chunk(&mut cursor)?;
                match lfo_count {
                    0 => keygroup.lfo1 = Some(lfo),
                    1 => keygroup.lfo2 = Some(lfo),
                    _ => {}
                }
                lfo_count += 1;
            }
            _ => {}
        }
    }
    Ok(keygroup)
}

fn read_chunk_header(file: &mut File) -> io::Result<RiffChunkHeader> {
    let mut buf = [0u8; 4];
    file.read_exact(&mut buf)?;
    let id = str::from_utf8(&buf).unwrap_or("????").trim_end_matches('\0').to_string();
    let size = file.read_u32::<LittleEndian>()?;
    Ok(RiffChunkHeader { id, size })
}

fn parse_program_header(cursor: &mut Cursor<Vec<u8>>) -> io::Result<ProgramHeader> {
    cursor.seek(SeekFrom::Start(1))?;
    let midi_program_number = cursor.read_u8()?;
    let number_of_keygroups = cursor.read_u8()?;
    Ok(ProgramHeader { midi_program_number, number_of_keygroups })
}

fn parse_zone_chunk(cursor: &mut Cursor<Vec<u8>>, keygroup: &mut Keygroup) -> io::Result<()> {
    cursor.seek(SeekFrom::Start(1))?;
    keygroup.low_key = cursor.read_u8()?;
    keygroup.high_key = cursor.read_u8()?;
    keygroup.low_vel = cursor.read_u8()?;
    keygroup.high_vel = cursor.read_u8()?;
    Ok(())
}

fn parse_smpl_chunk(cursor: &mut Cursor<Vec<u8>>) -> io::Result<Sample> {
    cursor.seek(SeekFrom::Start(2))?;
    let mut buffer = Vec::new();
    cursor.read_to_end(&mut buffer)?;
    let end = buffer.iter().position(|&b| b == 0).unwrap_or(buffer.len());
    let filename = String::from_utf8_lossy(&buffer[..end]).to_string();
    Ok(Sample { filename })
}

fn parse_tune_chunk(cursor: &mut Cursor<Vec<u8>>) -> io::Result<Tune> {
    cursor.seek(SeekFrom::Start(2))?;
    let level = cursor.read_u8()?;
    let semitone = cursor.read_i8()?;
    let fine_tune = cursor.read_i8()?;
    Ok(Tune { level, semitone, fine_tune })
}

fn parse_filt_chunk(cursor: &mut Cursor<Vec<u8>>) -> io::Result<Filter> {
    cursor.seek(SeekFrom::Start(2))?;
    let cutoff = cursor.read_u8()?;
    let resonance = cursor.read_u8()?;
    cursor.seek(SeekFrom::Start(7))?;
    let filter_type = cursor.read_u8()?;
    Ok(Filter { cutoff, resonance, filter_type })
}

fn parse_env_chunk(cursor: &mut Cursor<Vec<u8>>) -> io::Result<Envelope> {
    cursor.seek(SeekFrom::Start(2))?;
    let attack = cursor.read_u8()?;
    let decay = cursor.read_u8()?;
    let sustain = cursor.read_u8()?;
    let release = cursor.read_u8()?;
    Ok(Envelope { attack, decay, sustain, release })
}

fn parse_lfo_chunk(cursor: &mut Cursor<Vec<u8>>) -> io::Result<Lfo> {
    cursor.seek(SeekFrom::Start(5))?;
    let waveform = cursor.read_u8()?;
    let rate = cursor.read_u8()?;
    let delay = cursor.read_u8()?;
    let depth = cursor.read_u8()?;
    Ok(Lfo { waveform, rate, delay, depth })
}
